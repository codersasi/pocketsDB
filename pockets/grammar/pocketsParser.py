# Generated from grammar/pockets.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3$")
        buf.write("\u00a0\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\3\2\3\2\6\2%\n\2\r")
        buf.write("\2\16\2&\3\2\3\2\3\3\3\3\3\3\3\3\5\3/\n\3\3\4\3\4\3\4")
        buf.write("\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\7\5?\n\5")
        buf.write("\f\5\16\5B\13\5\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\5\7O\n\7\3\b\3\b\3\b\3\b\7\bU\n\b\f\b\16\bX\13")
        buf.write("\b\3\b\3\b\3\t\3\t\3\t\3\t\3\n\3\n\3\n\7\nc\n\n\f\n\16")
        buf.write("\nf\13\n\3\13\3\13\3\13\7\13k\n\13\f\13\16\13n\13\13\3")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\7\f{\n\f\f")
        buf.write("\f\16\f~\13\f\3\r\3\r\3\16\3\16\3\16\5\16\u0085\n\16\3")
        buf.write("\17\3\17\3\17\3\17\5\17\u008b\n\17\3\20\3\20\3\20\5\20")
        buf.write("\u0090\n\20\3\20\3\20\5\20\u0094\n\20\3\20\3\20\6\20\u0098")
        buf.write("\n\20\r\20\16\20\u0099\5\20\u009c\n\20\3\21\3\21\3\21")
        buf.write("\2\3\26\22\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \2\4")
        buf.write("\4\2\25\25\31\35\3\2\27\30\2\u00a5\2$\3\2\2\2\4.\3\2\2")
        buf.write("\2\6\60\3\2\2\2\b\65\3\2\2\2\nC\3\2\2\2\fG\3\2\2\2\16")
        buf.write("P\3\2\2\2\20[\3\2\2\2\22_\3\2\2\2\24g\3\2\2\2\26o\3\2")
        buf.write("\2\2\30\177\3\2\2\2\32\u0084\3\2\2\2\34\u008a\3\2\2\2")
        buf.write("\36\u009b\3\2\2\2 \u009d\3\2\2\2\"%\5\4\3\2#%\7\3\2\2")
        buf.write("$\"\3\2\2\2$#\3\2\2\2%&\3\2\2\2&$\3\2\2\2&\'\3\2\2\2\'")
        buf.write("(\3\2\2\2()\7\2\2\3)\3\3\2\2\2*/\5\6\4\2+/\5\b\5\2,/\5")
        buf.write("\n\6\2-/\5\f\7\2.*\3\2\2\2.+\3\2\2\2.,\3\2\2\2.-\3\2\2")
        buf.write("\2/\5\3\2\2\2\60\61\7\4\2\2\61\62\7\7\2\2\62\63\5 \21")
        buf.write("\2\63\64\5\16\b\2\64\7\3\2\2\2\65\66\7\b\2\2\66\67\7\t")
        buf.write("\2\2\678\7\7\2\289\5 \21\29:\5\16\b\2:;\7\n\2\2;@\5\20")
        buf.write("\t\2<=\7\21\2\2=?\5\20\t\2><\3\2\2\2?B\3\2\2\2@>\3\2\2")
        buf.write("\2@A\3\2\2\2A\t\3\2\2\2B@\3\2\2\2CD\7\16\2\2DE\7\7\2\2")
        buf.write("EF\5 \21\2F\13\3\2\2\2GH\7\5\2\2HI\5\24\13\2IJ\7\6\2\2")
        buf.write("JK\7\7\2\2KN\5 \21\2LM\7\r\2\2MO\5\26\f\2NL\3\2\2\2NO")
        buf.write("\3\2\2\2O\r\3\2\2\2PQ\7\23\2\2QV\5\34\17\2RS\7\21\2\2")
        buf.write("SU\5\34\17\2TR\3\2\2\2UX\3\2\2\2VT\3\2\2\2VW\3\2\2\2W")
        buf.write("Y\3\2\2\2XV\3\2\2\2YZ\7\24\2\2Z\17\3\2\2\2[\\\7\23\2\2")
        buf.write("\\]\5\22\n\2]^\7\24\2\2^\21\3\2\2\2_d\5\36\20\2`a\7\21")
        buf.write("\2\2ac\5\36\20\2b`\3\2\2\2cf\3\2\2\2db\3\2\2\2de\3\2\2")
        buf.write("\2e\23\3\2\2\2fd\3\2\2\2gl\5\32\16\2hi\7\21\2\2ik\5\32")
        buf.write("\16\2jh\3\2\2\2kn\3\2\2\2lj\3\2\2\2lm\3\2\2\2m\25\3\2")
        buf.write("\2\2nl\3\2\2\2op\b\f\1\2pq\5\34\17\2qr\5\30\r\2rs\5\32")
        buf.write("\16\2s|\3\2\2\2tu\f\4\2\2uv\7\36\2\2v{\5\26\f\5wx\f\3")
        buf.write("\2\2xy\7\37\2\2y{\5\26\f\4zt\3\2\2\2zw\3\2\2\2{~\3\2\2")
        buf.write("\2|z\3\2\2\2|}\3\2\2\2}\27\3\2\2\2~|\3\2\2\2\177\u0080")
        buf.write("\t\2\2\2\u0080\31\3\2\2\2\u0081\u0085\7\22\2\2\u0082\u0085")
        buf.write("\5\34\17\2\u0083\u0085\5\36\20\2\u0084\u0081\3\2\2\2\u0084")
        buf.write("\u0082\3\2\2\2\u0084\u0083\3\2\2\2\u0085\33\3\2\2\2\u0086")
        buf.write("\u0087\7#\2\2\u0087\u0088\7\20\2\2\u0088\u008b\7#\2\2")
        buf.write("\u0089\u008b\7#\2\2\u008a\u0086\3\2\2\2\u008a\u0089\3")
        buf.write("\2\2\2\u008b\35\3\2\2\2\u008c\u009c\7\17\2\2\u008d\u009c")
        buf.write("\5\34\17\2\u008e\u0090\t\3\2\2\u008f\u008e\3\2\2\2\u008f")
        buf.write("\u0090\3\2\2\2\u0090\u0091\3\2\2\2\u0091\u009c\7!\2\2")
        buf.write("\u0092\u0094\t\3\2\2\u0093\u0092\3\2\2\2\u0093\u0094\3")
        buf.write("\2\2\2\u0094\u0095\3\2\2\2\u0095\u009c\7\"\2\2\u0096\u0098")
        buf.write("\7 \2\2\u0097\u0096\3\2\2\2\u0098\u0099\3\2\2\2\u0099")
        buf.write("\u0097\3\2\2\2\u0099\u009a\3\2\2\2\u009a\u009c\3\2\2\2")
        buf.write("\u009b\u008c\3\2\2\2\u009b\u008d\3\2\2\2\u009b\u008f\3")
        buf.write("\2\2\2\u009b\u0093\3\2\2\2\u009b\u0097\3\2\2\2\u009c\37")
        buf.write("\3\2\2\2\u009d\u009e\5\34\17\2\u009e!\3\2\2\2\22$&.@N")
        buf.write("Vdlz|\u0084\u008a\u008f\u0093\u0099\u009b")
        return buf.getvalue()


class pocketsParser ( Parser ):

    grammarFileName = "pockets.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'.'", "','", "'*'", "'('", "')'", "'='", 
                     "'!'", "'-'", "'+'", "'>'", "'>='", "'<'", "'<='", 
                     "'!='" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "CREATE", "SELECT", "FROM", 
                      "FILE", "INSERT", "INTO", "ROWS", "UPDATE", "SET", 
                      "WHERE", "DELETE", "NULL", "DOT", "COMMA", "ASTERISK", 
                      "LEFT_PARENTHESIS", "RIGHT_PARENTHESIS", "EQUALS", 
                      "NOT", "MINUS", "PLUS", "GT", "GE", "LT", "LE", "NE", 
                      "AND", "OR", "QUOTED_STRING", "INTEGER_VALUE", "DECIMAL_VALUE", 
                      "IDENTIFIER", "WS" ]

    RULE_pocket = 0
    RULE_statement = 1
    RULE_create = 2
    RULE_insert = 3
    RULE_delete = 4
    RULE_select = 5
    RULE_columnNames = 6
    RULE_values = 7
    RULE_constants = 8
    RULE_expressionList = 9
    RULE_booleanExpression = 10
    RULE_compare = 11
    RULE_expression = 12
    RULE_identifier = 13
    RULE_constant = 14
    RULE_fileIdentifier = 15

    ruleNames =  [ "pocket", "statement", "create", "insert", "delete", 
                   "select", "columnNames", "values", "constants", "expressionList", 
                   "booleanExpression", "compare", "expression", "identifier", 
                   "constant", "fileIdentifier" ]

    EOF = Token.EOF
    T__0=1
    CREATE=2
    SELECT=3
    FROM=4
    FILE=5
    INSERT=6
    INTO=7
    ROWS=8
    UPDATE=9
    SET=10
    WHERE=11
    DELETE=12
    NULL=13
    DOT=14
    COMMA=15
    ASTERISK=16
    LEFT_PARENTHESIS=17
    RIGHT_PARENTHESIS=18
    EQUALS=19
    NOT=20
    MINUS=21
    PLUS=22
    GT=23
    GE=24
    LT=25
    LE=26
    NE=27
    AND=28
    OR=29
    QUOTED_STRING=30
    INTEGER_VALUE=31
    DECIMAL_VALUE=32
    IDENTIFIER=33
    WS=34

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class PocketContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(pocketsParser.EOF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.StatementContext)
            else:
                return self.getTypedRuleContext(pocketsParser.StatementContext,i)


        def getRuleIndex(self):
            return pocketsParser.RULE_pocket

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPocket" ):
                listener.enterPocket(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPocket" ):
                listener.exitPocket(self)




    def pocket(self):

        localctx = pocketsParser.PocketContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_pocket)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 34
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [pocketsParser.CREATE, pocketsParser.SELECT, pocketsParser.INSERT, pocketsParser.DELETE]:
                    self.state = 32
                    self.statement()
                    pass
                elif token in [pocketsParser.T__0]:
                    self.state = 33
                    self.match(pocketsParser.T__0)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 36 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << pocketsParser.T__0) | (1 << pocketsParser.CREATE) | (1 << pocketsParser.SELECT) | (1 << pocketsParser.INSERT) | (1 << pocketsParser.DELETE))) != 0)):
                    break

            self.state = 38
            self.match(pocketsParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def create(self):
            return self.getTypedRuleContext(pocketsParser.CreateContext,0)


        def insert(self):
            return self.getTypedRuleContext(pocketsParser.InsertContext,0)


        def delete(self):
            return self.getTypedRuleContext(pocketsParser.DeleteContext,0)


        def select(self):
            return self.getTypedRuleContext(pocketsParser.SelectContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = pocketsParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 44
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [pocketsParser.CREATE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 40
                self.create()
                pass
            elif token in [pocketsParser.INSERT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 41
                self.insert()
                pass
            elif token in [pocketsParser.DELETE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 42
                self.delete()
                pass
            elif token in [pocketsParser.SELECT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 43
                self.select()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(pocketsParser.CREATE, 0)

        def FILE(self):
            return self.getToken(pocketsParser.FILE, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(pocketsParser.FileIdentifierContext,0)


        def columnNames(self):
            return self.getTypedRuleContext(pocketsParser.ColumnNamesContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_create

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate" ):
                listener.enterCreate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate" ):
                listener.exitCreate(self)




    def create(self):

        localctx = pocketsParser.CreateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_create)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 46
            self.match(pocketsParser.CREATE)
            self.state = 47
            self.match(pocketsParser.FILE)
            self.state = 48
            self.fileIdentifier()
            self.state = 49
            self.columnNames()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSERT(self):
            return self.getToken(pocketsParser.INSERT, 0)

        def INTO(self):
            return self.getToken(pocketsParser.INTO, 0)

        def FILE(self):
            return self.getToken(pocketsParser.FILE, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(pocketsParser.FileIdentifierContext,0)


        def columnNames(self):
            return self.getTypedRuleContext(pocketsParser.ColumnNamesContext,0)


        def ROWS(self):
            return self.getToken(pocketsParser.ROWS, 0)

        def values(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.ValuesContext)
            else:
                return self.getTypedRuleContext(pocketsParser.ValuesContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.COMMA)
            else:
                return self.getToken(pocketsParser.COMMA, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_insert

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert" ):
                listener.enterInsert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert" ):
                listener.exitInsert(self)




    def insert(self):

        localctx = pocketsParser.InsertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_insert)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self.match(pocketsParser.INSERT)
            self.state = 52
            self.match(pocketsParser.INTO)
            self.state = 53
            self.match(pocketsParser.FILE)
            self.state = 54
            self.fileIdentifier()
            self.state = 55
            self.columnNames()
            self.state = 56
            self.match(pocketsParser.ROWS)
            self.state = 57
            self.values()
            self.state = 62
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==pocketsParser.COMMA:
                self.state = 58
                self.match(pocketsParser.COMMA)
                self.state = 59
                self.values()
                self.state = 64
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeleteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE(self):
            return self.getToken(pocketsParser.DELETE, 0)

        def FILE(self):
            return self.getToken(pocketsParser.FILE, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(pocketsParser.FileIdentifierContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_delete

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelete" ):
                listener.enterDelete(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelete" ):
                listener.exitDelete(self)




    def delete(self):

        localctx = pocketsParser.DeleteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_delete)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65
            self.match(pocketsParser.DELETE)
            self.state = 66
            self.match(pocketsParser.FILE)
            self.state = 67
            self.fileIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(pocketsParser.SELECT, 0)

        def expressionList(self):
            return self.getTypedRuleContext(pocketsParser.ExpressionListContext,0)


        def FROM(self):
            return self.getToken(pocketsParser.FROM, 0)

        def FILE(self):
            return self.getToken(pocketsParser.FILE, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(pocketsParser.FileIdentifierContext,0)


        def WHERE(self):
            return self.getToken(pocketsParser.WHERE, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(pocketsParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_select

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect" ):
                listener.enterSelect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect" ):
                listener.exitSelect(self)




    def select(self):

        localctx = pocketsParser.SelectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_select)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(pocketsParser.SELECT)
            self.state = 70
            self.expressionList()
            self.state = 71
            self.match(pocketsParser.FROM)
            self.state = 72
            self.match(pocketsParser.FILE)
            self.state = 73
            self.fileIdentifier()
            self.state = 76
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==pocketsParser.WHERE:
                self.state = 74
                self.match(pocketsParser.WHERE)
                self.state = 75
                self.booleanExpression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnNamesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(pocketsParser.LEFT_PARENTHESIS, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(pocketsParser.IdentifierContext,i)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(pocketsParser.RIGHT_PARENTHESIS, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.COMMA)
            else:
                return self.getToken(pocketsParser.COMMA, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_columnNames

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnNames" ):
                listener.enterColumnNames(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnNames" ):
                listener.exitColumnNames(self)




    def columnNames(self):

        localctx = pocketsParser.ColumnNamesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_columnNames)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.match(pocketsParser.LEFT_PARENTHESIS)
            self.state = 79
            self.identifier()
            self.state = 84
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==pocketsParser.COMMA:
                self.state = 80
                self.match(pocketsParser.COMMA)
                self.state = 81
                self.identifier()
                self.state = 86
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 87
            self.match(pocketsParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(pocketsParser.LEFT_PARENTHESIS, 0)

        def constants(self):
            return self.getTypedRuleContext(pocketsParser.ConstantsContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(pocketsParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return pocketsParser.RULE_values

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValues" ):
                listener.enterValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValues" ):
                listener.exitValues(self)




    def values(self):

        localctx = pocketsParser.ValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_values)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 89
            self.match(pocketsParser.LEFT_PARENTHESIS)
            self.state = 90
            self.constants()
            self.state = 91
            self.match(pocketsParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.ConstantContext)
            else:
                return self.getTypedRuleContext(pocketsParser.ConstantContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.COMMA)
            else:
                return self.getToken(pocketsParser.COMMA, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_constants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstants" ):
                listener.enterConstants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstants" ):
                listener.exitConstants(self)




    def constants(self):

        localctx = pocketsParser.ConstantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_constants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.constant()
            self.state = 98
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==pocketsParser.COMMA:
                self.state = 94
                self.match(pocketsParser.COMMA)
                self.state = 95
                self.constant()
                self.state = 100
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(pocketsParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.COMMA)
            else:
                return self.getToken(pocketsParser.COMMA, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_expressionList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionList" ):
                listener.enterExpressionList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionList" ):
                listener.exitExpressionList(self)




    def expressionList(self):

        localctx = pocketsParser.ExpressionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_expressionList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.expression()
            self.state = 106
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==pocketsParser.COMMA:
                self.state = 102
                self.match(pocketsParser.COMMA)
                self.state = 103
                self.expression()
                self.state = 108
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # BooleanExpressionContext
            self.operator = None # Token
            self.right = None # BooleanExpressionContext

        def identifier(self):
            return self.getTypedRuleContext(pocketsParser.IdentifierContext,0)


        def compare(self):
            return self.getTypedRuleContext(pocketsParser.CompareContext,0)


        def expression(self):
            return self.getTypedRuleContext(pocketsParser.ExpressionContext,0)


        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(pocketsParser.BooleanExpressionContext,i)


        def AND(self):
            return self.getToken(pocketsParser.AND, 0)

        def OR(self):
            return self.getToken(pocketsParser.OR, 0)

        def getRuleIndex(self):
            return pocketsParser.RULE_booleanExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanExpression" ):
                listener.enterBooleanExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanExpression" ):
                listener.exitBooleanExpression(self)



    def booleanExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = pocketsParser.BooleanExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 20
        self.enterRecursionRule(localctx, 20, self.RULE_booleanExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 110
            self.identifier()
            self.state = 111
            self.compare()
            self.state = 112
            self.expression()
            self._ctx.stop = self._input.LT(-1)
            self.state = 122
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 120
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
                    if la_ == 1:
                        localctx = pocketsParser.BooleanExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 114
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 115
                        localctx.operator = self.match(pocketsParser.AND)
                        self.state = 116
                        localctx.right = self.booleanExpression(3)
                        pass

                    elif la_ == 2:
                        localctx = pocketsParser.BooleanExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 117
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 118
                        localctx.operator = self.match(pocketsParser.OR)
                        self.state = 119
                        localctx.right = self.booleanExpression(2)
                        pass

             
                self.state = 124
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class CompareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUALS(self):
            return self.getToken(pocketsParser.EQUALS, 0)

        def GT(self):
            return self.getToken(pocketsParser.GT, 0)

        def GE(self):
            return self.getToken(pocketsParser.GE, 0)

        def LT(self):
            return self.getToken(pocketsParser.LT, 0)

        def LE(self):
            return self.getToken(pocketsParser.LE, 0)

        def NE(self):
            return self.getToken(pocketsParser.NE, 0)

        def getRuleIndex(self):
            return pocketsParser.RULE_compare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompare" ):
                listener.enterCompare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompare" ):
                listener.exitCompare(self)




    def compare(self):

        localctx = pocketsParser.CompareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_compare)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << pocketsParser.EQUALS) | (1 << pocketsParser.GT) | (1 << pocketsParser.GE) | (1 << pocketsParser.LT) | (1 << pocketsParser.LE) | (1 << pocketsParser.NE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASTERISK(self):
            return self.getToken(pocketsParser.ASTERISK, 0)

        def identifier(self):
            return self.getTypedRuleContext(pocketsParser.IdentifierContext,0)


        def constant(self):
            return self.getTypedRuleContext(pocketsParser.ConstantContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = pocketsParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_expression)
        try:
            self.state = 130
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 127
                self.match(pocketsParser.ASTERISK)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 128
                self.identifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 129
                self.constant()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.IDENTIFIER)
            else:
                return self.getToken(pocketsParser.IDENTIFIER, i)

        def DOT(self):
            return self.getToken(pocketsParser.DOT, 0)

        def getRuleIndex(self):
            return pocketsParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = pocketsParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_identifier)
        try:
            self.state = 136
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 132
                self.match(pocketsParser.IDENTIFIER)
                self.state = 133
                self.match(pocketsParser.DOT)
                self.state = 134
                self.match(pocketsParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 135
                self.match(pocketsParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULL(self):
            return self.getToken(pocketsParser.NULL, 0)

        def identifier(self):
            return self.getTypedRuleContext(pocketsParser.IdentifierContext,0)


        def INTEGER_VALUE(self):
            return self.getToken(pocketsParser.INTEGER_VALUE, 0)

        def MINUS(self):
            return self.getToken(pocketsParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(pocketsParser.PLUS, 0)

        def DECIMAL_VALUE(self):
            return self.getToken(pocketsParser.DECIMAL_VALUE, 0)

        def QUOTED_STRING(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.QUOTED_STRING)
            else:
                return self.getToken(pocketsParser.QUOTED_STRING, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = pocketsParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.state = 153
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 138
                self.match(pocketsParser.NULL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 139
                self.identifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 141
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==pocketsParser.MINUS or _la==pocketsParser.PLUS:
                    self.state = 140
                    _la = self._input.LA(1)
                    if not(_la==pocketsParser.MINUS or _la==pocketsParser.PLUS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 143
                self.match(pocketsParser.INTEGER_VALUE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 145
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==pocketsParser.MINUS or _la==pocketsParser.PLUS:
                    self.state = 144
                    _la = self._input.LA(1)
                    if not(_la==pocketsParser.MINUS or _la==pocketsParser.PLUS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 147
                self.match(pocketsParser.DECIMAL_VALUE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 149 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 148
                        self.match(pocketsParser.QUOTED_STRING)

                    else:
                        raise NoViableAltException(self)
                    self.state = 151 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def identifier(self):
            return self.getTypedRuleContext(pocketsParser.IdentifierContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_fileIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileIdentifier" ):
                listener.enterFileIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileIdentifier" ):
                listener.exitFileIdentifier(self)




    def fileIdentifier(self):

        localctx = pocketsParser.FileIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_fileIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            localctx.name = self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[10] = self.booleanExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def booleanExpression_sempred(self, localctx:BooleanExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         




